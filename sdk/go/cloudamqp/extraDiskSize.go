// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudamqp

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudamqp/sdk/v3/go/cloudamqp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource allows you to resize the disk with additional storage capacity.
//
// ***Before v1.25.0***: Only available for Amazon Web Services (AWS) without downtime.
//
// ***From v1.25.0***: Google Compute Engine (GCE) and Azure available.
//
// Introducing a new optional argument called `allowDowntime`.  Leaving it out or set it to false will proceed to try and resize the disk without downtime, available for *AWS* and *GCE*.
// While *Azure* only support swapping the disk, and this argument needs to be set to *true*.
//
// `allowDowntime` also makes it possible to circumvent the time rate limit or shrinking the disk.
//
// |         Cloud         |        allow_        |          allow_          |
// |-----------------------|----------------------|--------------------------|
// | amazon-web-services   | Expand current disk* | Try to expand, otherwise |
// | google-compute-engine | Expand current disk* | Try to expand, otherwise |
// | azure-arm             | Not                  | Swap disk to new         |
type ExtraDiskSize struct {
	pulumi.CustomResourceState

	// When resizing disk, allow cluster downtime to do so
	AllowDowntime pulumi.BoolPtrOutput `pulumi:"allowDowntime"`
	// Extra disk size in GB
	ExtraDiskSize pulumi.IntOutput `pulumi:"extraDiskSize"`
	// Instance identifier
	InstanceId pulumi.IntOutput             `pulumi:"instanceId"`
	Nodes      ExtraDiskSizeNodeArrayOutput `pulumi:"nodes"`
	// Configurable sleep time in seconds between retries for resizing the disk
	Sleep pulumi.IntPtrOutput `pulumi:"sleep"`
	// Configurable timeout time in seconds for resizing the disk
	Timeout pulumi.IntPtrOutput `pulumi:"timeout"`
}

// NewExtraDiskSize registers a new resource with the given unique name, arguments, and options.
func NewExtraDiskSize(ctx *pulumi.Context,
	name string, args *ExtraDiskSizeArgs, opts ...pulumi.ResourceOption) (*ExtraDiskSize, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ExtraDiskSize == nil {
		return nil, errors.New("invalid value for required argument 'ExtraDiskSize'")
	}
	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ExtraDiskSize
	err := ctx.RegisterResource("cloudamqp:index/extraDiskSize:ExtraDiskSize", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetExtraDiskSize gets an existing ExtraDiskSize resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetExtraDiskSize(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ExtraDiskSizeState, opts ...pulumi.ResourceOption) (*ExtraDiskSize, error) {
	var resource ExtraDiskSize
	err := ctx.ReadResource("cloudamqp:index/extraDiskSize:ExtraDiskSize", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ExtraDiskSize resources.
type extraDiskSizeState struct {
	// When resizing disk, allow cluster downtime to do so
	AllowDowntime *bool `pulumi:"allowDowntime"`
	// Extra disk size in GB
	ExtraDiskSize *int `pulumi:"extraDiskSize"`
	// Instance identifier
	InstanceId *int                `pulumi:"instanceId"`
	Nodes      []ExtraDiskSizeNode `pulumi:"nodes"`
	// Configurable sleep time in seconds between retries for resizing the disk
	Sleep *int `pulumi:"sleep"`
	// Configurable timeout time in seconds for resizing the disk
	Timeout *int `pulumi:"timeout"`
}

type ExtraDiskSizeState struct {
	// When resizing disk, allow cluster downtime to do so
	AllowDowntime pulumi.BoolPtrInput
	// Extra disk size in GB
	ExtraDiskSize pulumi.IntPtrInput
	// Instance identifier
	InstanceId pulumi.IntPtrInput
	Nodes      ExtraDiskSizeNodeArrayInput
	// Configurable sleep time in seconds between retries for resizing the disk
	Sleep pulumi.IntPtrInput
	// Configurable timeout time in seconds for resizing the disk
	Timeout pulumi.IntPtrInput
}

func (ExtraDiskSizeState) ElementType() reflect.Type {
	return reflect.TypeOf((*extraDiskSizeState)(nil)).Elem()
}

type extraDiskSizeArgs struct {
	// When resizing disk, allow cluster downtime to do so
	AllowDowntime *bool `pulumi:"allowDowntime"`
	// Extra disk size in GB
	ExtraDiskSize int `pulumi:"extraDiskSize"`
	// Instance identifier
	InstanceId int `pulumi:"instanceId"`
	// Configurable sleep time in seconds between retries for resizing the disk
	Sleep *int `pulumi:"sleep"`
	// Configurable timeout time in seconds for resizing the disk
	Timeout *int `pulumi:"timeout"`
}

// The set of arguments for constructing a ExtraDiskSize resource.
type ExtraDiskSizeArgs struct {
	// When resizing disk, allow cluster downtime to do so
	AllowDowntime pulumi.BoolPtrInput
	// Extra disk size in GB
	ExtraDiskSize pulumi.IntInput
	// Instance identifier
	InstanceId pulumi.IntInput
	// Configurable sleep time in seconds between retries for resizing the disk
	Sleep pulumi.IntPtrInput
	// Configurable timeout time in seconds for resizing the disk
	Timeout pulumi.IntPtrInput
}

func (ExtraDiskSizeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*extraDiskSizeArgs)(nil)).Elem()
}

type ExtraDiskSizeInput interface {
	pulumi.Input

	ToExtraDiskSizeOutput() ExtraDiskSizeOutput
	ToExtraDiskSizeOutputWithContext(ctx context.Context) ExtraDiskSizeOutput
}

func (*ExtraDiskSize) ElementType() reflect.Type {
	return reflect.TypeOf((**ExtraDiskSize)(nil)).Elem()
}

func (i *ExtraDiskSize) ToExtraDiskSizeOutput() ExtraDiskSizeOutput {
	return i.ToExtraDiskSizeOutputWithContext(context.Background())
}

func (i *ExtraDiskSize) ToExtraDiskSizeOutputWithContext(ctx context.Context) ExtraDiskSizeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExtraDiskSizeOutput)
}

// ExtraDiskSizeArrayInput is an input type that accepts ExtraDiskSizeArray and ExtraDiskSizeArrayOutput values.
// You can construct a concrete instance of `ExtraDiskSizeArrayInput` via:
//
//	ExtraDiskSizeArray{ ExtraDiskSizeArgs{...} }
type ExtraDiskSizeArrayInput interface {
	pulumi.Input

	ToExtraDiskSizeArrayOutput() ExtraDiskSizeArrayOutput
	ToExtraDiskSizeArrayOutputWithContext(context.Context) ExtraDiskSizeArrayOutput
}

type ExtraDiskSizeArray []ExtraDiskSizeInput

func (ExtraDiskSizeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ExtraDiskSize)(nil)).Elem()
}

func (i ExtraDiskSizeArray) ToExtraDiskSizeArrayOutput() ExtraDiskSizeArrayOutput {
	return i.ToExtraDiskSizeArrayOutputWithContext(context.Background())
}

func (i ExtraDiskSizeArray) ToExtraDiskSizeArrayOutputWithContext(ctx context.Context) ExtraDiskSizeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExtraDiskSizeArrayOutput)
}

// ExtraDiskSizeMapInput is an input type that accepts ExtraDiskSizeMap and ExtraDiskSizeMapOutput values.
// You can construct a concrete instance of `ExtraDiskSizeMapInput` via:
//
//	ExtraDiskSizeMap{ "key": ExtraDiskSizeArgs{...} }
type ExtraDiskSizeMapInput interface {
	pulumi.Input

	ToExtraDiskSizeMapOutput() ExtraDiskSizeMapOutput
	ToExtraDiskSizeMapOutputWithContext(context.Context) ExtraDiskSizeMapOutput
}

type ExtraDiskSizeMap map[string]ExtraDiskSizeInput

func (ExtraDiskSizeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ExtraDiskSize)(nil)).Elem()
}

func (i ExtraDiskSizeMap) ToExtraDiskSizeMapOutput() ExtraDiskSizeMapOutput {
	return i.ToExtraDiskSizeMapOutputWithContext(context.Background())
}

func (i ExtraDiskSizeMap) ToExtraDiskSizeMapOutputWithContext(ctx context.Context) ExtraDiskSizeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExtraDiskSizeMapOutput)
}

type ExtraDiskSizeOutput struct{ *pulumi.OutputState }

func (ExtraDiskSizeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ExtraDiskSize)(nil)).Elem()
}

func (o ExtraDiskSizeOutput) ToExtraDiskSizeOutput() ExtraDiskSizeOutput {
	return o
}

func (o ExtraDiskSizeOutput) ToExtraDiskSizeOutputWithContext(ctx context.Context) ExtraDiskSizeOutput {
	return o
}

// When resizing disk, allow cluster downtime to do so
func (o ExtraDiskSizeOutput) AllowDowntime() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ExtraDiskSize) pulumi.BoolPtrOutput { return v.AllowDowntime }).(pulumi.BoolPtrOutput)
}

// Extra disk size in GB
func (o ExtraDiskSizeOutput) ExtraDiskSize() pulumi.IntOutput {
	return o.ApplyT(func(v *ExtraDiskSize) pulumi.IntOutput { return v.ExtraDiskSize }).(pulumi.IntOutput)
}

// Instance identifier
func (o ExtraDiskSizeOutput) InstanceId() pulumi.IntOutput {
	return o.ApplyT(func(v *ExtraDiskSize) pulumi.IntOutput { return v.InstanceId }).(pulumi.IntOutput)
}

func (o ExtraDiskSizeOutput) Nodes() ExtraDiskSizeNodeArrayOutput {
	return o.ApplyT(func(v *ExtraDiskSize) ExtraDiskSizeNodeArrayOutput { return v.Nodes }).(ExtraDiskSizeNodeArrayOutput)
}

// Configurable sleep time in seconds between retries for resizing the disk
func (o ExtraDiskSizeOutput) Sleep() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ExtraDiskSize) pulumi.IntPtrOutput { return v.Sleep }).(pulumi.IntPtrOutput)
}

// Configurable timeout time in seconds for resizing the disk
func (o ExtraDiskSizeOutput) Timeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ExtraDiskSize) pulumi.IntPtrOutput { return v.Timeout }).(pulumi.IntPtrOutput)
}

type ExtraDiskSizeArrayOutput struct{ *pulumi.OutputState }

func (ExtraDiskSizeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ExtraDiskSize)(nil)).Elem()
}

func (o ExtraDiskSizeArrayOutput) ToExtraDiskSizeArrayOutput() ExtraDiskSizeArrayOutput {
	return o
}

func (o ExtraDiskSizeArrayOutput) ToExtraDiskSizeArrayOutputWithContext(ctx context.Context) ExtraDiskSizeArrayOutput {
	return o
}

func (o ExtraDiskSizeArrayOutput) Index(i pulumi.IntInput) ExtraDiskSizeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ExtraDiskSize {
		return vs[0].([]*ExtraDiskSize)[vs[1].(int)]
	}).(ExtraDiskSizeOutput)
}

type ExtraDiskSizeMapOutput struct{ *pulumi.OutputState }

func (ExtraDiskSizeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ExtraDiskSize)(nil)).Elem()
}

func (o ExtraDiskSizeMapOutput) ToExtraDiskSizeMapOutput() ExtraDiskSizeMapOutput {
	return o
}

func (o ExtraDiskSizeMapOutput) ToExtraDiskSizeMapOutputWithContext(ctx context.Context) ExtraDiskSizeMapOutput {
	return o
}

func (o ExtraDiskSizeMapOutput) MapIndex(k pulumi.StringInput) ExtraDiskSizeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ExtraDiskSize {
		return vs[0].(map[string]*ExtraDiskSize)[vs[1].(string)]
	}).(ExtraDiskSizeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ExtraDiskSizeInput)(nil)).Elem(), &ExtraDiskSize{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExtraDiskSizeArrayInput)(nil)).Elem(), ExtraDiskSizeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExtraDiskSizeMapInput)(nil)).Elem(), ExtraDiskSizeMap{})
	pulumi.RegisterOutputType(ExtraDiskSizeOutput{})
	pulumi.RegisterOutputType(ExtraDiskSizeArrayOutput{})
	pulumi.RegisterOutputType(ExtraDiskSizeMapOutput{})
}
