# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ExtraDiskSizeNodeArgs',
    'ExtraDiskSizeNodeArgsDict',
    'InstanceCopySettingArgs',
    'InstanceCopySettingArgsDict',
    'IntegrationMetricPrometheusAzureMonitorArgs',
    'IntegrationMetricPrometheusAzureMonitorArgsDict',
    'IntegrationMetricPrometheusCloudwatchV3Args',
    'IntegrationMetricPrometheusCloudwatchV3ArgsDict',
    'IntegrationMetricPrometheusDatadogV3Args',
    'IntegrationMetricPrometheusDatadogV3ArgsDict',
    'IntegrationMetricPrometheusDynatraceArgs',
    'IntegrationMetricPrometheusDynatraceArgsDict',
    'IntegrationMetricPrometheusNewrelicV3Args',
    'IntegrationMetricPrometheusNewrelicV3ArgsDict',
    'IntegrationMetricPrometheusSplunkV2Args',
    'IntegrationMetricPrometheusSplunkV2ArgsDict',
    'IntegrationMetricPrometheusStackdriverV2Args',
    'IntegrationMetricPrometheusStackdriverV2ArgsDict',
    'NotificationResponderArgs',
    'NotificationResponderArgsDict',
    'SecurityFirewallRuleArgs',
    'SecurityFirewallRuleArgsDict',
    'TrustStoreHttpArgs',
    'TrustStoreHttpArgsDict',
]

MYPY = False

if not MYPY:
    class ExtraDiskSizeNodeArgsDict(TypedDict):
        additional_disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Additional added disk size
        """
        disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Subscription plan disk size
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the node.
        """
elif False:
    ExtraDiskSizeNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtraDiskSizeNodeArgs:
    def __init__(__self__, *,
                 additional_disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] additional_disk_size: Additional added disk size
        :param pulumi.Input[_builtins.int] disk_size: Subscription plan disk size
        :param pulumi.Input[_builtins.str] name: Name of the node.
        """
        if additional_disk_size is not None:
            pulumi.set(__self__, "additional_disk_size", additional_disk_size)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="additionalDiskSize")
    def additional_disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Additional added disk size
        """
        return pulumi.get(self, "additional_disk_size")

    @additional_disk_size.setter
    def additional_disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "additional_disk_size", value)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Subscription plan disk size
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "disk_size", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InstanceCopySettingArgsDict(TypedDict):
        settings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Array of one or more settings to be copied. Allowed values:
        [alarms, config, definitions, firewall, logs, metrics, plugins]

        See more below, [copy settings].
        """
        subscription_id: pulumi.Input[_builtins.str]
        """
        Instance identifier of the CloudAMQP instance to copy the settings
        from.
        """
elif False:
    InstanceCopySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCopySettingArgs:
    def __init__(__self__, *,
                 settings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subscription_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] settings: Array of one or more settings to be copied. Allowed values:
               [alarms, config, definitions, firewall, logs, metrics, plugins]
               
               See more below, [copy settings].
        :param pulumi.Input[_builtins.str] subscription_id: Instance identifier of the CloudAMQP instance to copy the settings
               from.
        """
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "subscription_id", subscription_id)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Array of one or more settings to be copied. Allowed values:
        [alarms, config, definitions, firewall, logs, metrics, plugins]

        See more below, [copy settings].
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[_builtins.str]:
        """
        Instance identifier of the CloudAMQP instance to copy the settings
        from.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subscription_id", value)


if not MYPY:
    class IntegrationMetricPrometheusAzureMonitorArgsDict(TypedDict):
        connection_string: pulumi.Input[_builtins.str]
        """
        Azure Application Insights Connection String for authentication.
        """
elif False:
    IntegrationMetricPrometheusAzureMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationMetricPrometheusAzureMonitorArgs:
    def __init__(__self__, *,
                 connection_string: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] connection_string: Azure Application Insights Connection String for authentication.
        """
        pulumi.set(__self__, "connection_string", connection_string)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> pulumi.Input[_builtins.str]:
        """
        Azure Application Insights Connection String for authentication.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_string", value)


if not MYPY:
    class IntegrationMetricPrometheusCloudwatchV3ArgsDict(TypedDict):
        iam_external_id: pulumi.Input[_builtins.str]
        """
        AWS IAM external ID for role assumption.
        """
        iam_role: pulumi.Input[_builtins.str]
        """
        AWS IAM role ARN with PutMetricData permission for CloudWatch integration.
        """
        region: pulumi.Input[_builtins.str]
        """
        AWS region for CloudWatch metrics.
        """
        tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
elif False:
    IntegrationMetricPrometheusCloudwatchV3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationMetricPrometheusCloudwatchV3Args:
    def __init__(__self__, *,
                 iam_external_id: pulumi.Input[_builtins.str],
                 iam_role: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] iam_external_id: AWS IAM external ID for role assumption.
        :param pulumi.Input[_builtins.str] iam_role: AWS IAM role ARN with PutMetricData permission for CloudWatch integration.
        :param pulumi.Input[_builtins.str] region: AWS region for CloudWatch metrics.
        :param pulumi.Input[_builtins.str] tags: Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        pulumi.set(__self__, "iam_external_id", iam_external_id)
        pulumi.set(__self__, "iam_role", iam_role)
        pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="iamExternalId")
    def iam_external_id(self) -> pulumi.Input[_builtins.str]:
        """
        AWS IAM external ID for role assumption.
        """
        return pulumi.get(self, "iam_external_id")

    @iam_external_id.setter
    def iam_external_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "iam_external_id", value)

    @_builtins.property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> pulumi.Input[_builtins.str]:
        """
        AWS IAM role ARN with PutMetricData permission for CloudWatch integration.
        """
        return pulumi.get(self, "iam_role")

    @iam_role.setter
    def iam_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "iam_role", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region for CloudWatch metrics.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class IntegrationMetricPrometheusDatadogV3ArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        Datadog API key for authentication.
        """
        region: pulumi.Input[_builtins.str]
        """
        Datadog region code. Valid values: `us1`, `us3`, `us5`, `eu1`.
        """
        rabbitmq_dashboard_metrics_format: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable metric name transformation to match Datadog's RabbitMQ dashboard format. Default: `false`. **Note:** This option is only available for RabbitMQ clusters, not LavinMQ clusters.
        """
        tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
elif False:
    IntegrationMetricPrometheusDatadogV3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationMetricPrometheusDatadogV3Args:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 rabbitmq_dashboard_metrics_format: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Datadog API key for authentication.
        :param pulumi.Input[_builtins.str] region: Datadog region code. Valid values: `us1`, `us3`, `us5`, `eu1`.
        :param pulumi.Input[_builtins.bool] rabbitmq_dashboard_metrics_format: Enable metric name transformation to match Datadog's RabbitMQ dashboard format. Default: `false`. **Note:** This option is only available for RabbitMQ clusters, not LavinMQ clusters.
        :param pulumi.Input[_builtins.str] tags: Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "region", region)
        if rabbitmq_dashboard_metrics_format is not None:
            pulumi.set(__self__, "rabbitmq_dashboard_metrics_format", rabbitmq_dashboard_metrics_format)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        Datadog API key for authentication.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Datadog region code. Valid values: `us1`, `us3`, `us5`, `eu1`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="rabbitmqDashboardMetricsFormat")
    def rabbitmq_dashboard_metrics_format(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable metric name transformation to match Datadog's RabbitMQ dashboard format. Default: `false`. **Note:** This option is only available for RabbitMQ clusters, not LavinMQ clusters.
        """
        return pulumi.get(self, "rabbitmq_dashboard_metrics_format")

    @rabbitmq_dashboard_metrics_format.setter
    def rabbitmq_dashboard_metrics_format(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "rabbitmq_dashboard_metrics_format", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class IntegrationMetricPrometheusDynatraceArgsDict(TypedDict):
        access_token: pulumi.Input[_builtins.str]
        """
        Dynatrace access token with 'Ingest metrics' permission.
        """
        environment_id: pulumi.Input[_builtins.str]
        """
        Dynatrace environment ID.
        """
        tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
elif False:
    IntegrationMetricPrometheusDynatraceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationMetricPrometheusDynatraceArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[_builtins.str],
                 environment_id: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_token: Dynatrace access token with 'Ingest metrics' permission.
        :param pulumi.Input[_builtins.str] environment_id: Dynatrace environment ID.
        :param pulumi.Input[_builtins.str] tags: Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "environment_id", environment_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[_builtins.str]:
        """
        Dynatrace access token with 'Ingest metrics' permission.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_token", value)

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> pulumi.Input[_builtins.str]:
        """
        Dynatrace environment ID.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "environment_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class IntegrationMetricPrometheusNewrelicV3ArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        New Relic API key for authentication.
        """
        region: pulumi.Input[_builtins.str]
        """
        New Relic region code. Valid values: `eu`, `us`.
        """
        tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
elif False:
    IntegrationMetricPrometheusNewrelicV3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationMetricPrometheusNewrelicV3Args:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: New Relic API key for authentication.
        :param pulumi.Input[_builtins.str] region: New Relic region code. Valid values: `eu`, `us`.
        :param pulumi.Input[_builtins.str] tags: Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        New Relic API key for authentication.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        New Relic region code. Valid values: `eu`, `us`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class IntegrationMetricPrometheusSplunkV2ArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Splunk HEC endpoint URL. Example: `https://your-instance-id.splunkcloud.com:8088/services/collector`.
        """
        token: pulumi.Input[_builtins.str]
        """
        Splunk HEC (HTTP Event Collector) token for authentication.
        """
        tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
elif False:
    IntegrationMetricPrometheusSplunkV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationMetricPrometheusSplunkV2Args:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: Splunk HEC endpoint URL. Example: `https://your-instance-id.splunkcloud.com:8088/services/collector`.
        :param pulumi.Input[_builtins.str] token: Splunk HEC (HTTP Event Collector) token for authentication.
        :param pulumi.Input[_builtins.str] tags: Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "token", token)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Splunk HEC endpoint URL. Example: `https://your-instance-id.splunkcloud.com:8088/services/collector`.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        Splunk HEC (HTTP Event Collector) token for authentication.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class IntegrationMetricPrometheusStackdriverV2ArgsDict(TypedDict):
        credentials_file: pulumi.Input[_builtins.str]
        """
        Base64-encoded Google service account key JSON file with 'Monitoring Metric Writer' permission.
        """
        client_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Google service account client email (extracted from credentials file).
        """
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Google service account private key (extracted from credentials file).
        """
        private_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Google service account private key ID (extracted from credentials file).
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Google Cloud project ID (extracted from credentials file).
        """
        tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.

        The following computed attributes are available:
        """
elif False:
    IntegrationMetricPrometheusStackdriverV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationMetricPrometheusStackdriverV2Args:
    def __init__(__self__, *,
                 credentials_file: pulumi.Input[_builtins.str],
                 client_email: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] credentials_file: Base64-encoded Google service account key JSON file with 'Monitoring Metric Writer' permission.
        :param pulumi.Input[_builtins.str] client_email: Google service account client email (extracted from credentials file).
        :param pulumi.Input[_builtins.str] private_key: Google service account private key (extracted from credentials file).
        :param pulumi.Input[_builtins.str] private_key_id: Google service account private key ID (extracted from credentials file).
        :param pulumi.Input[_builtins.str] project_id: Google Cloud project ID (extracted from credentials file).
        :param pulumi.Input[_builtins.str] tags: Additional tags to attach to metrics. Format: `key=value,key2=value2`.
               
               The following computed attributes are available:
        """
        pulumi.set(__self__, "credentials_file", credentials_file)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="credentialsFile")
    def credentials_file(self) -> pulumi.Input[_builtins.str]:
        """
        Base64-encoded Google service account key JSON file with 'Monitoring Metric Writer' permission.
        """
        return pulumi.get(self, "credentials_file")

    @credentials_file.setter
    def credentials_file(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_file", value)

    @_builtins.property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Google service account client email (extracted from credentials file).
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_email", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Google service account private key (extracted from credentials file).
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Google service account private key ID (extracted from credentials file).
        """
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key_id", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Google Cloud project ID (extracted from credentials file).
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional tags to attach to metrics. Format: `key=value,key2=value2`.

        The following computed attributes are available:
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NotificationResponderArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of responder. [`team`, `user`, `escalation`, `schedule`]
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier in UUID format
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the responder
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        Username of the responder

        Responders of type `team`, `escalation` and `schedule` can use either id or name.
        While `user` can use either id or username.
        """
elif False:
    NotificationResponderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationResponderArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of responder. [`team`, `user`, `escalation`, `schedule`]
        :param pulumi.Input[_builtins.str] id: Identifier in UUID format
        :param pulumi.Input[_builtins.str] name: Name of the responder
        :param pulumi.Input[_builtins.str] username: Username of the responder
               
               Responders of type `team`, `escalation` and `schedule` can use either id or name.
               While `user` can use either id or username.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of responder. [`team`, `user`, `escalation`, `schedule`]
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier in UUID format
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the responder
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Username of the responder

        Responders of type `team`, `escalation` and `schedule` can use either id or name.
        While `user` can use either id or username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class SecurityFirewallRuleArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        CIDR address: IP address with CIDR notation (e.g. 10.56.72.0/24)
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description name of the rule. e.g. Default.

        Pre-defined services for RabbitMQ:

        | Service name | Port  |
        |--------------|-------|
        | AMQP         | 5672  |
        | AMQPS        | 5671  |
        | HTTPS        | 443   |
        | MQTT         | 1883  |
        | MQTTS        | 8883  |
        | STOMP        | 61613 |
        | STOMPS       | 61614 |
        | STREAM       | 5552  |
        | STREAM_SSL   | 5551  |

        Pre-defined services for LavinMQ:

        | Service name | Port  |
        |--------------|-------|
        | AMQP         | 5672  |
        | AMQPS        | 5671  |
        | HTTPS        | 443   |
        | MQTT         | 1883  |
        | MQTTS        | 8883  |
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Custom ports to be opened
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pre-defined service ports, see table below
        """
elif False:
    SecurityFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityFirewallRuleArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: CIDR address: IP address with CIDR notation (e.g. 10.56.72.0/24)
        :param pulumi.Input[_builtins.str] description: Description name of the rule. e.g. Default.
               
               Pre-defined services for RabbitMQ:
               
               | Service name | Port  |
               |--------------|-------|
               | AMQP         | 5672  |
               | AMQPS        | 5671  |
               | HTTPS        | 443   |
               | MQTT         | 1883  |
               | MQTTS        | 8883  |
               | STOMP        | 61613 |
               | STOMPS       | 61614 |
               | STREAM       | 5552  |
               | STREAM_SSL   | 5551  |
               
               Pre-defined services for LavinMQ:
               
               | Service name | Port  |
               |--------------|-------|
               | AMQP         | 5672  |
               | AMQPS        | 5671  |
               | HTTPS        | 443   |
               | MQTT         | 1883  |
               | MQTTS        | 8883  |
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ports: Custom ports to be opened
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] services: Pre-defined service ports, see table below
        """
        pulumi.set(__self__, "ip", ip)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        CIDR address: IP address with CIDR notation (e.g. 10.56.72.0/24)
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description name of the rule. e.g. Default.

        Pre-defined services for RabbitMQ:

        | Service name | Port  |
        |--------------|-------|
        | AMQP         | 5672  |
        | AMQPS        | 5671  |
        | HTTPS        | 443   |
        | MQTT         | 1883  |
        | MQTTS        | 8883  |
        | STOMP        | 61613 |
        | STOMPS       | 61614 |
        | STREAM       | 5552  |
        | STREAM_SSL   | 5551  |

        Pre-defined services for LavinMQ:

        | Service name | Port  |
        |--------------|-------|
        | AMQP         | 5672  |
        | AMQPS        | 5671  |
        | HTTPS        | 443   |
        | MQTT         | 1883  |
        | MQTTS        | 8883  |
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Custom ports to be opened
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pre-defined service ports, see table below
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class TrustStoreHttpArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        URL to fetch trust store certificates from. RabbitMQ will periodically
        fetch CA certificates from this URL.
        """
        cacert: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        PEM encoded CA certificates used to verify the HTTPS connection to the
        trust store URL. This is a write-only field - changes are only applied when `version`
        is incremented.
        """
elif False:
    TrustStoreHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrustStoreHttpArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 cacert: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: URL to fetch trust store certificates from. RabbitMQ will periodically
               fetch CA certificates from this URL.
        :param pulumi.Input[_builtins.str] cacert: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
               PEM encoded CA certificates used to verify the HTTPS connection to the
               trust store URL. This is a write-only field - changes are only applied when `version`
               is incremented.
        """
        pulumi.set(__self__, "url", url)
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        URL to fetch trust store certificates from. RabbitMQ will periodically
        fetch CA certificates from this URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def cacert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        PEM encoded CA certificates used to verify the HTTPS connection to the
        trust store URL. This is a write-only field - changes are only applied when `version`
        is incremented.
        """
        return pulumi.get(self, "cacert")

    @cacert.setter
    def cacert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cacert", value)


